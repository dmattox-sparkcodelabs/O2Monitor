"""Data models for O2 Monitor.

This module contains all the data classes and enums used throughout the application.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional
import uuid


class AVAPSState(Enum):
    """AVAPS therapy device power state."""
    ON = "on"           # Power > on_threshold (therapy active)
    OFF = "off"         # Power < off_threshold (standby/unplugged)
    UNKNOWN = "unknown" # Network error or startup


class MonitorState(Enum):
    """Overall system monitoring state."""
    INITIALIZING = "initializing"       # System starting up
    DISCONNECTED = "disconnected"       # BLE not connected
    THERAPY_ACTIVE = "therapy_active"   # AVAPS on, suppress SpO2 alarms
    NORMAL = "normal"                   # AVAPS off, SpO2 >= 90%
    LOW_SPO2_WARNING = "low_spo2_warning"  # AVAPS off, SpO2 < 90%, countdown started
    ALARM = "alarm"                     # SpO2 < 90% for 30+ sec, AVAPS off
    SILENCED = "silenced"               # User silenced alerts temporarily


class AlertSeverity(Enum):
    """Alert severity levels."""
    CRITICAL = "critical"  # SpO2 alarm - immediate action required
    WARNING = "warning"    # BLE disconnect, degraded operation
    INFO = "info"          # System notifications, status updates


class AlertType(Enum):
    """Types of alerts the system can generate."""
    SPO2_LOW = "spo2_low"              # Oxygen saturation below threshold
    BLE_DISCONNECT = "ble_disconnect"  # Lost connection to oximeter
    SYSTEM_ERROR = "system_error"      # Internal error
    TEST = "test"                      # Test alert


@dataclass
class OxiReading:
    """A single reading from the pulse oximeter.

    Attributes:
        timestamp: When the reading was taken
        spo2: Oxygen saturation percentage (0-100)
        heart_rate: Heart rate in BPM
        battery_level: Device battery percentage (0-100)
        movement: Movement indicator from device
        is_valid: False if finger not detected or reading invalid
    """
    timestamp: datetime
    spo2: int
    heart_rate: int
    battery_level: int = 0
    movement: int = 0
    is_valid: bool = True

    def __post_init__(self):
        """Validate reading values."""
        if self.spo2 < 0 or self.spo2 > 100:
            raise ValueError(f"SpO2 must be 0-100, got {self.spo2}")
        if self.heart_rate < 0 or self.heart_rate > 300:
            raise ValueError(f"Heart rate must be 0-300, got {self.heart_rate}")

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            "timestamp": self.timestamp.isoformat(),
            "spo2": self.spo2,
            "heart_rate": self.heart_rate,
            "battery_level": self.battery_level,
            "movement": self.movement,
            "is_valid": self.is_valid,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "OxiReading":
        """Create from dictionary."""
        return cls(
            timestamp=datetime.fromisoformat(data["timestamp"]),
            spo2=data["spo2"],
            heart_rate=data["heart_rate"],
            battery_level=data.get("battery_level", 0),
            movement=data.get("movement", 0),
            is_valid=data.get("is_valid", True),
        )


@dataclass
class Alert:
    """An alert generated by the monitoring system.

    Attributes:
        id: Unique identifier for this alert
        alert_type: Type of alert (SPO2_LOW, BLE_DISCONNECT, etc.)
        severity: Severity level (CRITICAL, WARNING, INFO)
        message: Human-readable alert message
        timestamp: When the alert was created
        spo2: SpO2 reading at time of alert (if applicable)
        heart_rate: Heart rate at time of alert (if applicable)
        avaps_state: AVAPS state at time of alert
        acknowledged: Whether alert has been acknowledged
        acknowledged_at: When alert was acknowledged
        acknowledged_by: Who acknowledged the alert
        resolved: Whether alert condition has resolved
        resolved_at: When alert was resolved
    """
    alert_type: AlertType
    severity: AlertSeverity
    message: str
    timestamp: datetime = field(default_factory=datetime.now)
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    spo2: Optional[int] = None
    heart_rate: Optional[int] = None
    avaps_state: AVAPSState = AVAPSState.UNKNOWN
    acknowledged: bool = False
    acknowledged_at: Optional[datetime] = None
    acknowledged_by: Optional[str] = None
    resolved: bool = False
    resolved_at: Optional[datetime] = None

    def acknowledge(self, by: str = "user") -> None:
        """Mark alert as acknowledged."""
        self.acknowledged = True
        self.acknowledged_at = datetime.now()
        self.acknowledged_by = by

    def resolve(self) -> None:
        """Mark alert as resolved."""
        self.resolved = True
        self.resolved_at = datetime.now()

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            "id": self.id,
            "alert_type": self.alert_type.value,
            "severity": self.severity.value,
            "message": self.message,
            "timestamp": self.timestamp.isoformat(),
            "spo2": self.spo2,
            "heart_rate": self.heart_rate,
            "avaps_state": self.avaps_state.value,
            "acknowledged": self.acknowledged,
            "acknowledged_at": self.acknowledged_at.isoformat() if self.acknowledged_at else None,
            "acknowledged_by": self.acknowledged_by,
            "resolved": self.resolved,
            "resolved_at": self.resolved_at.isoformat() if self.resolved_at else None,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "Alert":
        """Create from dictionary."""
        return cls(
            id=data["id"],
            alert_type=AlertType(data["alert_type"]),
            severity=AlertSeverity(data["severity"]),
            message=data["message"],
            timestamp=datetime.fromisoformat(data["timestamp"]),
            spo2=data.get("spo2"),
            heart_rate=data.get("heart_rate"),
            avaps_state=AVAPSState(data.get("avaps_state", "unknown")),
            acknowledged=data.get("acknowledged", False),
            acknowledged_at=datetime.fromisoformat(data["acknowledged_at"]) if data.get("acknowledged_at") else None,
            acknowledged_by=data.get("acknowledged_by"),
            resolved=data.get("resolved", False),
            resolved_at=datetime.fromisoformat(data["resolved_at"]) if data.get("resolved_at") else None,
        )


@dataclass
class BLEStatus:
    """Status of the BLE connection to the oximeter.

    Attributes:
        connected: Whether currently connected
        device_name: Name of the connected device
        mac_address: MAC address of the device
        battery_level: Device battery percentage
        last_reading_time: When last reading was received
        connection_attempts: Number of connection attempts since last success
        last_error: Last connection error message
    """
    connected: bool = False
    device_name: str = ""
    mac_address: str = ""
    battery_level: Optional[int] = None
    last_reading_time: Optional[datetime] = None
    connection_attempts: int = 0
    last_error: Optional[str] = None

    @property
    def last_reading_age_seconds(self) -> Optional[float]:
        """Seconds since last reading, or None if no reading."""
        if self.last_reading_time is None:
            return None
        return (datetime.now() - self.last_reading_time).total_seconds()

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            "connected": self.connected,
            "device_name": self.device_name,
            "mac_address": self.mac_address,
            "battery_level": self.battery_level,
            "last_reading_time": self.last_reading_time.isoformat() if self.last_reading_time else None,
            "last_reading_age_seconds": self.last_reading_age_seconds,
            "connection_attempts": self.connection_attempts,
            "last_error": self.last_error,
        }


@dataclass
class SystemStatus:
    """Comprehensive system status snapshot for API responses.

    This is the main data structure returned by /api/status.
    """
    timestamp: datetime = field(default_factory=datetime.now)
    state: MonitorState = MonitorState.INITIALIZING

    # Current vitals
    current_reading: Optional[OxiReading] = None

    # Component status
    ble_status: BLEStatus = field(default_factory=BLEStatus)
    avaps_state: AVAPSState = AVAPSState.UNKNOWN
    avaps_power_watts: Optional[float] = None

    # Alert status
    alerts_silenced: bool = False
    silence_remaining_seconds: Optional[int] = None
    active_alert_count: int = 0

    # System health
    uptime_seconds: float = 0
    last_heartbeat_time: Optional[datetime] = None

    # Warning states
    low_spo2_start_time: Optional[datetime] = None

    @property
    def low_spo2_duration_seconds(self) -> Optional[float]:
        """Seconds in low SpO2 state, or None if not in warning."""
        if self.low_spo2_start_time is None:
            return None
        return (datetime.now() - self.low_spo2_start_time).total_seconds()

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            "timestamp": self.timestamp.isoformat(),
            "state": self.state.value,
            "vitals": self.current_reading.to_dict() if self.current_reading else None,
            "ble": self.ble_status.to_dict(),
            "avaps": {
                "state": self.avaps_state.value,
                "power_watts": self.avaps_power_watts,
            },
            "alerts": {
                "silenced": self.alerts_silenced,
                "silence_remaining_seconds": self.silence_remaining_seconds,
                "active_count": self.active_alert_count,
            },
            "system": {
                "uptime_seconds": self.uptime_seconds,
                "last_heartbeat_time": self.last_heartbeat_time.isoformat() if self.last_heartbeat_time else None,
            },
            "warning": {
                "low_spo2_start_time": self.low_spo2_start_time.isoformat() if self.low_spo2_start_time else None,
                "low_spo2_duration_seconds": self.low_spo2_duration_seconds,
            },
        }
